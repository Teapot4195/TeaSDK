//
// Created by teapot on 25/10/23.
//

#ifndef TEASDK_TOKENIZER_H
#define TEASDK_TOKENIZER_H

#include <string>
#include <vector>
#include <fstream>
#include <unordered_map>
#include <cstring>
#include <cstdint>
#include <functional>
#include <list>
#include <variant>

namespace tcc89 {

    struct preprocessor_symbols {
        std::unordered_map<std::string, std::string> Macro;
        std::unordered_map<std::string, std::pair<std::vector<std::string>, std::string>> ParamMacro;
    };

    enum Token_Type {
        Tok_Preprocessor, ///< Used to denote a place where the preprocessor might need to do something
        Tok_Whitespace, ///< Used to help with analysis
        Tok_Newline, ///< Special use for marking newlines
        Tok_Newline_Fold, ///< Special use for marking folded newlines
        Tok_Comment, ///< Not very useful, but here anyways

        Tok_Ident,
        Tok_Keyword,
        Tok_IntConstant,
        Tok_CharacterConstant,
        Tok_FloatingConstant,
        Tok_String,

        /* Paired Separators */
        Tok_Paren_Open,
        Tok_Paren_Close,
        Tok_Square_Open,
        Tok_Square_Close,
        Tok_Curly_Open,
        Tok_Curly_Close,
        Tok_Angle_Open,
        Tok_Angle_Close,

        /* Unpaired separators */
        Tok_EQ,
        Tok_Semicolon,
        Tok_Star,
        Tok_Comma,
        Tok_Period,
        Tok_Slash,
        Tok_Percent,
        Tok_Plus,
        Tok_Minus,
        Tok_Ampersand,
        Tok_Hat,
        Tok_Pipe,
        Tok_Question,
        Tok_Colon,
        Tok_Excl,
        Tok_Tilde,

        Tok_EOF, ///< Represents end of file
    };

    struct Token {
        Token_Type type;
        bool WIDE;
        std::variant<std::monostate, std::string, std::wstring> str;
        std::variant<std::monostate, std::int64_t, std::uint64_t, double> int_data;
        bool UNSIGNED, L, FLOAT;
        std::variant<std::monostate, char, wchar_t> char_data;
    };

    class Tokenizer {
    public:
        /**
         * @brief builds a tokenizer with the symbol table and file
         *
         * @param table symbol table
         * @param file file to load from
         */
        Tokenizer(preprocessor_symbols symbols, const std::string& file);

        /**
         * @brief builds a tokenizer with the symbol table and file
         *
         * @param table symbol table
         * @param file file to load from
         */
        Tokenizer(preprocessor_symbols symbols, std::ifstream file, std::string  filepath);

        /**
         * @brief loads a new file
         *
         * @param file file to load
         */
        void load_file(const std::string& file);

        /**
         * @brief loads a new file
         *
         * @param file file to load
         */
        void load_file(std::ifstream file);

        /**
         * @brief tokenizes the loaded file, includes executing preprocessor conditions
         *
         * @return the list of processed tokens
         */
        std::vector<Token> tokenize();

        /**
         * @brief prints the tokens generated by the parser
         *
         * @param toks tokens to print
         */
        static void print(const std::vector<Token>& toks);

    private:
        preprocessor_symbols table;
        std::ifstream file_stream;
        std::string filepath;
    };
}

#endif //TEASDK_TOKENIZER_H
